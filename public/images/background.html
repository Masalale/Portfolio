<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superpowered Logo</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
        body {
            background-color: black;
            height: 100vh;  
            display: grid;
            place-items: center;
            margin: 0;
            overflow: hidden;
            font-family: "Rubik", sans-serif;
        }

        /* Morphing blob animation */
        @keyframes rotate {
            from {
                rotate: 0deg;
            }
            
            50% {
                scale: 1 1.5;
            }
            
            to {
                rotate: 360deg;
            }
        }

        #blob {
            height: 300px;
            width: 300px;
            position: absolute;
            left: 50%;
            top: 50%;
            translate: -50% -50%;
            border-radius: 50%;
            background: transparent;
            animation: rotate 20s infinite;
            pointer-events: none;
            z-index: 1;
        }

        #logo-grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            will-change: transform;
        }

        .mini-logo {
            position: absolute;
            width: 30px;
            aspect-ratio: 1000 / 556;
            user-select: none;
        }

        .mini-logo > img {
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
        }
    </style>
</head>
<body>

    <div id="blob"></div>
    <div id="logo-grid"></div>

    <script>
const gridContainer = document.getElementById("logo-grid");
const blob = document.getElementById("blob");
const miniLogos = [];
let mouseX = window.innerWidth / 2;
let mouseY = window.innerHeight / 2;

const GRID_SPACING = 45;
const MINI_LOGO_SIZE = 30;
const EFFECT_RADIUS = 200;

const createMiniLogo = (x, y) => {
    const wrapper = document.createElement("div");
    wrapper.className = "mini-logo";
    wrapper.style.left = `${x}px`;
    wrapper.style.top = `${y}px`;

    const logoImages = [];
    for (let i = 1; i <= 5; i++) {
        const img = document.createElement("img");
        img.src = `logo_0${i}.png`;
        img.draggable = false;
        wrapper.appendChild(img);
        logoImages.push(img);
    }

    gridContainer.appendChild(wrapper);

    miniLogos.push({
        wrapper,
        images: logoImages,
        x: x + (MINI_LOGO_SIZE / 2),
        y: y + (MINI_LOGO_SIZE * 556 / 1000 / 2),
        lastDistance: Infinity
    });
};

const buildGrid = () => {
    gridContainer.innerHTML = "";
    miniLogos.length = 0;

    const cols = Math.ceil(window.innerWidth / GRID_SPACING) + 1;
    const rows = Math.ceil(window.innerHeight / GRID_SPACING) + 1;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const x = col * GRID_SPACING;
            const y = row * GRID_SPACING;
            createMiniLogo(x, y);
        }
    }
};

const updateLogoPositions = () => {
    const blobRect = blob.getBoundingClientRect();
    const blobCenterX = blobRect.left + blobRect.width / 2;
    const blobCenterY = blobRect.top + blobRect.height / 2;
    
    // Get actual blob dimensions considering animation scale
    const blobRadiusX = blobRect.width / 2;
    const blobRadiusY = blobRect.height / 2;
    const avgBlobRadius = (blobRadiusX + blobRadiusY) / 2;

    miniLogos.forEach((miniLogo) => {
        const dx = blobCenterX - miniLogo.x;
        const dy = blobCenterY - miniLogo.y;
        
        // Calculate distance considering blob's elliptical shape
        const normalizedDx = dx / blobRadiusX;
        const normalizedDy = dy / blobRadiusY;
        const ellipticalDistance = Math.sqrt(normalizedDx * normalizedDx + normalizedDy * normalizedDy);
        const distance = ellipticalDistance * avgBlobRadius;

        if (distance < avgBlobRadius) {
            const rangeX = dx / EFFECT_RADIUS;
            const rangeY = dy / EFFECT_RADIUS;

            miniLogo.images.forEach((img, index) => {
                const translationIntensity = 8;
                const maxTranslation = translationIntensity * (index + 1);
                const x = maxTranslation * rangeX;
                const y = maxTranslation * rangeY;

                gsap.to(img, {
                    x: `${x}%`,
                    y: `${y}%`,
                    duration: 0.3,
                    ease: "power2.out",
                    overwrite: "auto"
                });
            });
            miniLogo.lastDistance = distance;
        } else {
            // Always reset if not in proximity
            if (miniLogo.lastDistance !== Infinity) {
                miniLogo.images.forEach(img => {
                    gsap.to(img, {
                        x: "0%",
                        y: "0%",
                        duration: 0.6,
                        ease: "power2.out",
                        overwrite: "auto"
                    });
                });
                miniLogo.lastDistance = Infinity;
            }
        }
    });
};

// Continuous update loop for smooth blob tracking
const tick = () => {
    updateLogoPositions();
    requestAnimationFrame(tick);
};

window.addEventListener("pointermove", (event) => {
    mouseX = event.clientX;
    mouseY = event.clientY;
    
    // Use GSAP for smooth blob movement
    gsap.to(blob, {
        left: mouseX,
        top: mouseY,
        duration: 0.8,
        ease: "power2.out"
    });
});

window.addEventListener("resize", buildGrid);

buildGrid();
tick();
    </script>
</body>
</html>
